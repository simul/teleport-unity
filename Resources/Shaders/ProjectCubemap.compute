
// (c) 2020 Simul.co

#pragma kernel EncodeTagDataIdCS
#pragma kernel EncodeColorCS

#include "Common.cginc"

static const int2 FaceOffsets[] = { {0,0},{1,0},{2,0},{0,1},{1,1},{2,1} };

Texture2D<float4> InputColorTexture;
RWTexture2D<float4> RWOutputColorTexture;

int2 TagDataIdOffset;
int TagDataId;
int Face;

// Here. we will encode the uid of the video tag data in blocks of monochrome colour.
[numthreads(32, 1, 1)]
void EncodeTagDataIdCS(uint2 ThreadID : SV_DispatchThreadID)
{
	uint OutputW, OutputH;
	RWOutputColorTexture.GetDimensions(OutputW, OutputH);

	// We want to encode one 32-bit number with the minimum possible loss.
	// Therefore we will encode it in...
	// Binary.
	uint raw_uint = asuint(TagDataId);

	// We will use the thread x as the bit index.
	uint3 masked_bits = (raw_uint >> (ThreadID.x / 4))& uint(1);		// 1 or 0
	int2 Pos = TagDataIdOffset;
	Pos.x += int(ThreadID.x);
	// y will always stay the same
	float4 X = masked_bits.xxxx;
	RWOutputColorTexture[Pos] = X;
}

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void EncodeColorCS(uint2 ThreadID : SV_DispatchThreadID)
{
	uint InputW, InputH;
	InputColorTexture.GetDimensions(InputW, InputH);

	if (ThreadID.x >= InputW || ThreadID.y >= InputH)
		return;

	int2 pos = int2(ThreadID);
	int2 ipos=int2(pos.x,InputH-1-pos.y);
	float4 SceneColor = InputColorTexture[ipos];
	SceneColor.x = sqrt(SceneColor.x);
	SceneColor.y = sqrt(SceneColor.y);
	SceneColor.z = sqrt(SceneColor.z);

	pos += FaceOffsets[Face] * InputW;

	RWOutputColorTexture[pos] = SceneColor;
}


